---
title: 关于 monorepo 的一些感想
date: Tue Aug 24 2021 07:16:21 GMT+0800 (中国标准时间)
---
在 monorepo 之前，一直没有特别好的项目结构阐述具有一定弱关联或者具有依赖性质的项目之间的相处方式。

# 前奏

在前司，我们团队多次对于类似项目组头脑风暴。最初我们只是非常单纯的把各个 project 放在一起，如果 project 项目性质出现了区别，比如新增了小程序业务线，那我们会把 project 拆分成 web & mini。如果发现其中某个大类的 utils 可以被复用，自然而然会把他提取到层级更高的 utils 中。因此最初的 frontend 仓库处于非常原始的结构：

```
common
| -- xxxx.js
project
| -- web
    | -- projectA
    | -- projectB
    | -- utils
| -- h5
    | -- template
| -- mini
    | -- miniProjectA
    | -- miniProjectB
utils
```

就如同共产党宣言前的无产阶级，我们本能的去做更优的架构但因缺少中心思想而无从下手。

然后，我们认识到一些公用方法应当有更系统的管理办法，就如同它们总是被其他业务应用“依赖”一样，让他们成为真正的依赖。因此我们把它们抽离出来做成了一个个大大小小的 npm 包。

这同时产生了两个问题：a. 当 npm 包出现问题，我们需要不断的重复修改 npm 包代码 - 发布 - 更新业务代码依赖版本 - 在业务中调试，这让习惯了改一行 utils 代码直接能在业务代码中生效的我们来说无疑是灾难。b. 同时这让我们意识到一个一直存在却因此被无限放大的问题，我们无法有效的统一和规范项目的依赖版本，包括 ts、vue 等核心包的版本。

我们尝试开发脚手架去规范新建一个 project 的规范，但它总比不上 vue-cli 那么健壮。而且伴随着它的迭代会导致老的项目出现无法维护的问题。

在一次全公司的 codebase 调整之后，我们把大的 frontend 仓库按照项目复杂度拆分成了多个业务仓库，这个操作彻底放飞了每个仓库 owner 对项目架构设计的自由度。这使得即使我的同事就坐在我旁边工作，每天都有着交流，但让我去 clone 他负责的仓库帮助修复一些问题可能会要了我的老命。

遗憾的是，直到我离职我们团队的项目结构依然没有找到一个非常完美的方案（可以预见的是接手我项目的同事每天都抱着想掐死我的心情看代码）。

# monorepo......？......!

monorepo 已经有了非常好的实践（惭愧的是我在来字节之前都没有听说过），比较夸张的做法甚至是把整个公司的代码都塞到一个仓库里去，可能有人觉得这么做是疯了，不过在严格的 lint 、CI、review 下它确实能得到妥善的管理。

和副标题一致的是，在字节文档里第一次看到 monorepo 这个字眼的时候，我的脑海里缓缓打出一个问号，“这玩意是啥？”。然后当我深入的去使用了它，不得不感叹困扰我职业生涯将近一年多的问题在字节第一天的新人文档里找到了答案。其实 monorepo 从一开始所面向的就是更宏观的方向，这就是为什么 monorepo 是从 FB/Google 这些体量更大的公司得到发展，而不是从小公司开始兴起。

当我们决定做某个工程的时候，我们几乎无法确定他最终的代码体量和结构，我们总是在不断增减和回归中去修缮整体的结构，因此我们总是有众多仓库项目，同时我们总是在积极的创建更多的代码逻辑。为此我们会被迫使去为每个仓库下定义，也许基于某些原因会去拆分、合并仓库。然后我们必须花时间配置大量的代码规范、CI 逻辑、打包规则等。

所以如果要我总结 monorepo 最大的作用是简化组织结构，注意我用到了“组织”这个词汇，说明 monorepo 面向的不仅仅是一个小项目或一个简单的工程，它的出现更多的是整个公司或者部门对于管理 codebase 的深层次的思考。

在评价 monorepo 和 multiple repos 优劣势之前，首先我们要着眼 monorepo 解决了什么问题，然后我们就可以得到结论哪些工程应当使用 monorepo。写下这段话的时候让我想到了前段时间 Dan 的访谈：

> 主持人：有些用户已经尝试过使用 Server Component 了，所以当我们需要在项目中使用服务器组件的时候，我们需要维护三个组件而不是一个，这带来了额外的复杂性不是吗？

> Dan：对于这个问题而言，不是说你的组件在将来都会以三种形态存在，而是你现在只能用 Client Component 的组件。如果只用 Client Component 能够满足需求的话固然很好，但是当这个 Server Component 这个特性落地的时候，你会有更多的选择来做相同的事。

我认为这段话也很好的阐述了 monorepo 和 multiple repos 的关系。如果 single repo 能够很好的管理 code 那就固然是 ok 的，而 monorepo 的概念只不过让你有了更多的选择，我们要做的就是根据自己的情况做出较优的选择。

# monorepo 面临的问题

其实 monorepo 并不是什么新潮的概念，只不过最初的 codebase 设计者会本能的回避这种看起来很疯狂的架构。而到今天我们在面临复杂的代码库又回归到思考最初被我们放弃的选择时，我们仍然需要着手去解决某些 monorepo 下会暴露的问题。

这个我会在后续再做整理（给自己挖个坑？）